---
layout:     post
title:      Vulhub漏洞复现合集（下）
subtitle:   漏洞复现
date:       2020-10-16
author:     heria
header-img: img/post-bg-005.jpg
catalog: true
tags:
---

### CVE-2017-1000353 Jenkins-CI 远程代码执行漏洞

##### 漏洞简介及影响范围

Jenkins的反序列化漏洞，攻击者使用该漏洞可以在被攻击服务器执行任意代码，漏洞利用不需要任何的权限

漏洞影响范围：

所有Jenkins主版本均受到影响(包括<=2.56版本)
所有Jenkins LTS 均受到影响( 包括<=2.46.1版本)

##### 利用过程

生成序列化字符串

参考<https://github.com/vulhub/CVE-2017-1000353>，首先下载[CVE-2017-1000353-1.1-SNAPSHOT-all.jar](https://github.com/vulhub/CVE-2017-1000353/releases/download/1.1/CVE-2017-1000353-1.1-SNAPSHOT-all.jar)，这是生成POC的工具。

执行下面命令，生成字节码文件：

```bash
java -jar CVE-2017-1000353-1.1-SNAPSHOT-all.jar jenkins_poc.ser "command"
# jenkins_poc.ser是生成的字节码文件名
# "command ..."是待执行的任意命令
```

生成jenkins.ser文件 作用是在tmp文件夹下创建succc文件

![image-20210402135414150](https://raw.githubusercontent.com/heriachen/cloudimg/main/img2/image-20210402135414150.png)

发送数据包，执行命令

下载[exploit.py](https://github.com/vulhub/CVE-2017-1000353/blob/master/exploit.py)，(https://github.com/vulhub/CVE-2017-1000353/blob/master/exploit.py)， python3执行`python exploit.py http://your-ip:8080 jenkins.ser`，将刚才生成的字节码文件发送给目标

![image-20210402135433864](https://raw.githubusercontent.com/heriachen/cloudimg/main/img2/image-20210402135433864.png)

成功创建

![image-20210402135449599](https://raw.githubusercontent.com/heriachen/cloudimg/main/img2/image-20210402135449599.png)

更换反弹shell代码

![image-20210402135502880](https://raw.githubusercontent.com/heriachen/cloudimg/main/img2/image-20210402135502880.png)

执行后未能成功建立连接

尝试创建文件 之后通过echo 写入内容

![image-20210402135517862](https://raw.githubusercontent.com/heriachen/cloudimg/main/img2/image-20210402135517862.png)

执行后未能成功创建

![image-20210402135537565](https://raw.githubusercontent.com/heriachen/cloudimg/main/img2/image-20210402135537565.png)

更换思路 通过curl 下载文件  之后bash执行

创建名为1.txt文件 写入反弹shell语句

![image-20210402135556366](https://raw.githubusercontent.com/heriachen/cloudimg/main/img2/image-20210402135556366.png)

开启http服务 

![image-20210402135611051](https://raw.githubusercontent.com/heriachen/cloudimg/main/img2/image-20210402135611051.png)

访问对应端口

![image-20210402135624959](https://raw.githubusercontent.com/heriachen/cloudimg/main/img2/image-20210402135624959.png)

生成下载的序列化语句

![image-20210402135645784](https://raw.githubusercontent.com/heriachen/cloudimg/main/img2/image-20210402135645784.png)

执行

![image-20210402135700038](https://raw.githubusercontent.com/heriachen/cloudimg/main/img2/image-20210402135700038.png)

成功创建

![image-20210402135717295](https://raw.githubusercontent.com/heriachen/cloudimg/main/img2/image-20210402135717295.png)

再次生成一个序列化语句文件  内容为执行1.sh

![image-20210402135731632](https://raw.githubusercontent.com/heriachen/cloudimg/main/img2/image-20210402135731632.png)

执行

![image-20210402135747007](https://raw.githubusercontent.com/heriachen/cloudimg/main/img2/image-20210402135747007.png)

成功建立连接

![image-20210402135758644](https://raw.githubusercontent.com/heriachen/cloudimg/main/img2/image-20210402135758644.png)



### Apache SSI 远程命令执行漏洞

##### 漏洞简介及影响版本

在测试任意文件上传漏洞的时候，目标服务端可能不允许上传php后缀的文件。如果目标服务器开启了SSI与CGI支持，我们可以上传一个shtml文件，并利用`<!--#exec cmd="id" -->`语法执行任意命令。

##### 利用过程

利用后缀绕过但是无法解析

![image-20210402135817928](https://raw.githubusercontent.com/heriachen/cloudimg/main/img2/image-20210402135817928.png)

创建shtml文件

![image-20210402135837239](https://raw.githubusercontent.com/heriachen/cloudimg/main/img2/image-20210402135837239.png)

成功执行其中的ls命令

![image-20210402135848616](https://raw.githubusercontent.com/heriachen/cloudimg/main/img2/image-20210402135848616.png)

上传b.shtml文件 内容为

![image-20210402135904858](https://raw.githubusercontent.com/heriachen/cloudimg/main/img2/image-20210402135904858.png)

通过该文件创建test.sh文件 并将反弹shell指令写入test.shell文件

![image-20210402135917290](https://raw.githubusercontent.com/heriachen/cloudimg/main/img2/image-20210402135917290.png)

重新上传内容为bash test.sh的文件执行命令

![image-20210402135932252](https://raw.githubusercontent.com/heriachen/cloudimg/main/img2/image-20210402135932252.png)

成功弹shell

![image-20210402135947934](https://raw.githubusercontent.com/heriachen/cloudimg/main/img2/image-20210402135947934.png)



### CVE-2017-17562 GoAhead 远程命令执行漏洞

##### 漏洞简介及影响范围

GoAhead是一个开源(商业许可)、简单、轻巧、功能强大、可以在多个平台运行的Web Server，多用于嵌入式系统、智能设备。其支持运行ASP、Javascript和标准的CGI程序，这个漏洞就出现在运行CGI程序的时候。

GoAhead在接收到请求后，将会从URL参数中取出键和值注册进CGI程序的环境变量，且只过滤了`REMOTE_HOST`和`HTTP_AUTHORIZATION`。我们能够控制环境变量，就有很多攻击方式。比如在Linux中，`LD_`开头的环境变量和动态链接库有关，如`LD_PRELOAD`中指定的动态链接库，将会被自动加载；`LD_LIBRARY_PATH`指定的路径，程序会去其中寻找动态链接库。

我们可以指定`LD_PRELOAD=/proc/self/fd/0`，因为`/proc/self/fd/0`是标准输入，而在CGI程序中，POST数据流即为标准输入流。我们编译一个动态链接库，将其放在POST Body中，发送给`http://target/cgi-bin/index?LD_PRELOAD=/proc/self/fd/0`，CGI就会加载我们发送的动态链接库，造成远程命令执行漏洞。

##### 利用过程

我们首先需要编译一个动态链接库，而且需要和目标架构相同。所以在实战中，如果对方是一个智能设备，你可能需要交叉编译。因为Vulhub运行在`Linux x86_64`的机器中，所以我们直接用Linux PC编译即可。

![image-20210402140005285](https://raw.githubusercontent.com/heriachen/cloudimg/main/img2/image-20210402140005285.png)

![image-20210402140013475](https://raw.githubusercontent.com/heriachen/cloudimg/main/img2/image-20210402140013475.png)

将payload.so作为post body发送,可见，`Hello: world!`已被成功输出

![image-20210402140026451](https://raw.githubusercontent.com/heriachen/cloudimg/main/img2/image-20210402140026451.png)

使用msfvenom生成反弹shell的c代码

![image-20210402140042537](https://raw.githubusercontent.com/heriachen/cloudimg/main/img2/image-20210402140042537.png)

NX即No-eXecute（不可执行）的意思，NX（DEP）的基本原理是将数据所在内存页标识为不可执行，当程序溢出成功转入shellcode时，程序会尝试在数据页面上执行指令，此时CPU就会抛出异常，而不是去执行恶意指令。gcc -z execstack -o test test.c // 禁用NX保护

![image-20210402140105977](https://raw.githubusercontent.com/heriachen/cloudimg/main/img2/image-20210402140105977.png)

反弹成功

![image-20210402140124322](https://raw.githubusercontent.com/heriachen/cloudimg/main/img2/image-20210402140124322.png)

